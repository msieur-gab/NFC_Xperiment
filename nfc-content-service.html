<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Secure Message Service</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #f4f4f4;
            padding: 20px;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
        }
        .message-list {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 15px;
        }
        .encrypted-message {
            background-color: #f0f0f0;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            word-break: break-all;
            cursor: pointer;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
        .fab {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            background-color: #2563eb;
            color: white;
            border-radius: 50%;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            cursor: pointer;
            z-index: 100;
        }
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            z-index: 1000;
            display: none;
        }
        .write-modal {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: white;
            padding: 20px;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        textarea {
            width: 100%;
            height: 150px;
            margin-bottom: 10px;
        }
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ff3b30;
            margin-right: 5px;
        }
        .status-indicator.active {
            background-color: #34c759;
        }
        .status-bar {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            background-color: #f8f8f8;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        button {
            padding: 8px 16px;
            background-color: #2563eb;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
        }
        button:hover {
            background-color: #1d4ed8;
        }
        input {
            padding: 8px;
            margin-bottom: 10px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="status-bar">
            <span class="status-indicator" id="nfcStatus"></span>
            <span id="statusText">Authentication: None</span>
        </div>
        <div class="message-list" id="messageList">
            <h2>Encrypted Messages</h2>
            <!-- Encrypted messages will be loaded here -->
        </div>
    </div>

    <div id="securityModal" class="modal" style="display:none;">
        <div class="modal-content">
            <h2>Security Authentication</h2>
            <p>Please enter your private key or scan your NFC tag:</p>
            <input type="text" id="privateKeyInput" placeholder="Your private key">
            <button onclick="authenticateWithKey()">Authenticate</button>
            <hr style="margin: 15px 0;">
            <p>Or scan your NFC tag:</p>
            <button onclick="scanNFCTag()">Scan NFC Tag</button>
            <button onclick="closeSecurityModal()">Cancel</button>
        </div>
    </div>

    <div id="writeModal" class="write-modal" style="display:none;">
        <h2>Write New Message</h2>
        <textarea id="messageInput" placeholder="Enter your message"></textarea>
        <button onclick="saveMessage()">Save Message</button>
        <button onclick="closeWriteModal()">Cancel</button>
    </div>

    <button class="fab" onclick="openWriteModal()">+</button>

    <div id="toast" class="toast"></div>

    <script>
        let currentPrivateKey = null;
        let currentPublicId = null;
        let currentNFCData = null;
        let pendingWriteRequest = false;
        let pendingMessageKey = null;

        // Initialize on page load
        async function initializeMessages() {
            const messageList = document.getElementById('messageList');
            messageList.innerHTML = '<h2>Encrypted Messages</h2>';

            const keys = await localforage.keys();
            const encryptedKeys = keys.filter(key => key.startsWith('encrypted_'));

            if (encryptedKeys.length === 0) {
                messageList.innerHTML += '<p>No encrypted messages found.</p>';
                return;
            }

            for (const key of encryptedKeys) {
                const storedContent = await localforage.getItem(key);
                
                const messageDiv = document.createElement('div');
                messageDiv.className = 'encrypted-message';
                messageDiv.textContent = 'Encrypted message - click to decrypt';
                messageDiv.dataset.content = storedContent;
                
                // Add click event to show security modal
                messageDiv.addEventListener('click', () => {
                    document.getElementById('securityModal').style.display = 'flex';
                    // Store the clicked message content for later decryption
                    pendingMessageKey = key;
                });
                
                messageList.appendChild(messageDiv);
            }
        }

        function updateAuthStatus() {
            const statusIndicator = document.getElementById('nfcStatus');
            const statusText = document.getElementById('statusText');
            
            if (currentPrivateKey) {
                statusIndicator.classList.add('active');
                statusText.textContent = `Authenticated as: ${currentPublicId}`;
            } else {
                statusIndicator.classList.remove('active');
                statusText.textContent = 'Authentication: None';
            }
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.style.display = 'block';
            setTimeout(() => {
                toast.style.display = 'none';
            }, 3000);
        }

        function authenticateWithKey() {
            const privateKey = document.getElementById('privateKeyInput').value.trim();
            
            if (!privateKey) {
                showToast('Private key cannot be empty');
                return;
            }
            
            // Derive public ID from private key
            currentPrivateKey = privateKey;
            currentPublicId = CryptoJS.SHA256(privateKey).toString().substring(0, 16);
            
            updateAuthStatus();
            closeSecurityModal();
            showToast('Authentication successful');
            
            // If there was a pending message to decrypt
            if (pendingMessageKey) {
                decryptMessage(pendingMessageKey);
                pendingMessageKey = null;
            }
            
            // If there was a pending write request
            if (pendingWriteRequest) {
                pendingWriteRequest = false;
                openWriteModal();
            }
        }

        function openWriteModal() {
            if (!currentPrivateKey) {
                showToast('Please authenticate first');
                pendingWriteRequest = true;
                document.getElementById('securityModal').style.display = 'flex';
                return;
            }
            document.getElementById('writeModal').style.display = 'block';
        }

        function closeWriteModal() {
            document.getElementById('writeModal').style.display = 'none';
        }

        function closeSecurityModal() {
            document.getElementById('securityModal').style.display = 'none';
            document.getElementById('privateKeyInput').value = '';
        }

        async function decryptMessage(messageKey) {
            if (!currentPrivateKey) {
                showToast('Authentication required');
                return;
            }
            
            try {
                const storedContent = await localforage.getItem(messageKey);
                const messageData = JSON.parse(storedContent);
                
                // Try to decrypt with my private key
                if (messageData.targetPublicId === currentPublicId) {
                    // I'm the direct recipient
                    const decryptedText = CryptoJS.AES.decrypt(
                        messageData.encryptedContent, 
                        currentPrivateKey
                    ).toString(CryptoJS.enc.Utf8);
                    
                    // Update UI
                    updateDecryptedMessageUI(messageKey, decryptedText, true);
                    
                } else if (currentNFCData) {
                    // Check if I'm a reader with session key
                    const myReader = currentNFCData.readers.find(
                        r => r.publicId === currentPublicId
                    );
                    
                    if (myReader && messageData.sharedKeys[currentPublicId]) {
                        // I'm a reader with access
                        const sessionKey = myReader.sessionKey;
                        const messageKey = messageData.sharedKeys[currentPublicId];
                        
                        // Decrypt the message key with my session key
                        const decryptionKey = CryptoJS.AES.decrypt(
                            messageKey,
                            sessionKey
                        ).toString(CryptoJS.enc.Utf8);
                        
                        // Decrypt the message with the decryption key
                        const decryptedText = CryptoJS.AES.decrypt(
                            messageData.encryptedContent, 
                            decryptionKey
                        ).toString(CryptoJS.enc.Utf8);
                        
                        // Update UI
                        updateDecryptedMessageUI(messageKey, decryptedText, false);
                    } else {
                        showToast('You do not have permission to read this message');
                    }
                } else {
                    showToast('You do not have permission to read this message');
                }
                
            } catch (error) {
                console.error('Decryption error:', error);
                showToast('Failed to decrypt message');
            }
        }
        
        function updateDecryptedMessageUI(messageKey, decryptedText, isOwner) {
            // Find the message element
            const messageElements = document.querySelectorAll('.encrypted-message');
            messageElements.forEach(el => {
                if (el.dataset.content === messageKey) {
                    el.textContent = decryptedText;
                    
                    // Color based on relationship
                    if (isOwner) {
                        el.style.backgroundColor = '#e6f3e6'; // Green for owner
                    } else {
                        el.style.backgroundColor = '#fff3cd'; // Yellow for reader
                    }
                }
            });
        }

        async function saveMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();

            if (!message) {
                showToast('Message cannot be empty');
                return;
            }

            if (!currentPrivateKey) {
                showToast('Please authenticate first');
                return;
            }

            // Generate unique message ID
            const messageId = CryptoJS.SHA256(message + Date.now()).toString().substring(0, 12);
            
            // Generate a random encryption key for this message
            const messageEncryptionKey = CryptoJS.lib.WordArray.random(16).toString();
            
            // Prepare shared keys for readers - empty for now
            const sharedKeys = {};
            
            // If we have NFC data with readers, encrypt for them too
            if (currentNFCData && currentNFCData.readers) {
                currentNFCData.readers.forEach(reader => {
                    // Encrypt the message encryption key with the reader's session key
                    sharedKeys[reader.publicId] = CryptoJS.AES.encrypt(
                        messageEncryptionKey,
                        reader.sessionKey
                    ).toString();
                });
            }
            
            // Encrypt the message content with the message encryption key
            const encryptedContent = CryptoJS.AES.encrypt(
                message, 
                messageEncryptionKey
            ).toString();

            // Prepare the message structure
            const messageData = {
                targetPublicId: currentPublicId,
                encryptedContent: encryptedContent,
                sharedKeys: sharedKeys,
                timestamp: Date.now()
            };

            // Store the message
            await localforage.setItem(
                `encrypted_${messageId}`, 
                JSON.stringify(messageData)
            );

            messageInput.value = '';
            closeWriteModal();
            showToast('Message encrypted and saved');
            
            // Refresh message list
            await initializeMessages();
        }

        async function scanNFCTag() {
            if ('NDEFReader' in window) {
                try {
                    showToast('Scanning for NFC tag...');
                    const ndef = new NDEFReader();
                    await ndef.scan();

                    ndef.addEventListener("reading", async ({ message }) => {
                        const decoder = new TextDecoder();
                        const tagData = JSON.parse(
                            decoder.decode(message.records[0].data)
                        );

                        // Store NFC data
                        currentNFCData = tagData;
                        
                        // Check if I'm the owner
                        const privateKey = document.getElementById('privateKeyInput').value.trim();
                        if (privateKey) {
                            // Derive public ID from private key
                            const publicId = CryptoJS.SHA256(privateKey).toString().substring(0, 16);
                            
                            // If I'm the owner of this tag
                            if (publicId === tagData.owner.publicId) {
                                currentPrivateKey = privateKey;
                                currentPublicId = publicId;
                                updateAuthStatus();
                                showToast('Authenticated as tag owner');
                                
                                // Handle pending operations
                                handlePendingOperations();
                                return;
                            }
                        }
                        
                        // Check if I'm a reader
                        if (tagData.readers) {
                            // Ask for private key to identify as a reader
                            const privateKey = document.getElementById('privateKeyInput').value.trim();
                            if (privateKey) {
                                const publicId = CryptoJS.SHA256(privateKey).toString().substring(0, 16);
                                
                                // Check if this publicId is in the readers list
                                const myReaderInfo = tagData.readers.find(r => r.publicId === publicId);
                                
                                if (myReaderInfo) {
                                    currentPrivateKey = privateKey;
                                    currentPublicId = publicId;
                                    updateAuthStatus();
                                    showToast('Authenticated as reader');
                                    
                                    // Handle pending operations
                                    handlePendingOperations();
                                    return;
                                }
                            }
                        }
                        
                        showToast('Authentication needed - enter your private key');
                    });

                } catch (error) {
                    showToast(`NFC Error: ${error}`);
                }
            } else {
                showToast('NFC not supported on this device');
                
                // For testing on non-NFC devices, simulate a successful scan
                if (confirm("NFC not supported. Simulate successful scan for testing?")) {
                    simulateNFCScan();
                }
            }
        }
        
        function handlePendingOperations() {
            closeSecurityModal();
            
            // If there was a pending message to decrypt
            if (pendingMessageKey) {
                decryptMessage(pendingMessageKey);
                pendingMessageKey = null;
            }
            
            // If there was a pending write request
            if (pendingWriteRequest) {
                pendingWriteRequest = false;
                openWriteModal();
            }
        }
        
        // Function to simulate NFC scan for testing on non-NFC devices
        function simulateNFCScan() {
            // Simulate the NFC data
            const mockNFCData = {
                owner: {
                    publicId: "1234567890abcdef"
                },
                readers: [
                    { publicId: "abcdef1234567890", sessionKey: "reader-session-key-1" },
                    { publicId: "fedcba0987654321", sessionKey: "reader-session-key-2" }
                ]
            };
            
            // Store NFC data
            currentNFCData = mockNFCData;
            
            // For testing, ask the user what role they want to simulate
            const role = prompt("Enter role for simulation (owner/reader1/reader2):", "owner");
            
            if (role === "owner") {
                currentPrivateKey = "owner-private-key";
                currentPublicId = "1234567890abcdef";
            } else if (role === "reader1") {
                currentPrivateKey = "reader1-private-key";
                currentPublicId = "abcdef1234567890";
            } else if (role === "reader2") {
                currentPrivateKey = "reader2-private-key";
                currentPublicId = "fedcba0987654321";
            }
            
            updateAuthStatus();
            closeSecurityModal();
            
            // Handle pending operations
            handlePendingOperations();
            
            showToast(`Simulated NFC scan as ${role}`);
        }

        // Initialize messages on page load
        initializeMessages();
        updateAuthStatus();
    </script>
</body>
</html>